import { yellow } from "kleur/colors";
import {
  ActionQueryStringInvalidError,
  ActionsUsedWithForGetError
} from "../../core/errors/errors-data.js";
import { AstroError } from "../../core/errors/errors.js";
import { defineMiddleware } from "../../core/middleware/index.js";
import { formContentTypes, getAction, hasContentType } from "./utils.js";
import { getActionQueryString } from "./virtual/shared.js";
const onRequest = defineMiddleware(async (context, next) => {
  const locals = context.locals;
  const { request } = context;
  if (locals._actionsInternal) {
    locals._actionsInternal.callAction = createCallAction(context);
    return next();
  }
  if (request.method === "POST" && request.body === null) {
    return nextWithStaticStub(next, context);
  }
  const actionName = context.url.searchParams.get("_astroAction");
  if (context.request.method === "POST" && actionName) {
    return handlePost({ context, next, actionName });
  }
  if (context.request.method === "GET" && actionName) {
    throw new AstroError({
      ...ActionsUsedWithForGetError,
      message: ActionsUsedWithForGetError.message(actionName)
    });
  }
  if (context.request.method === "POST") {
    return handlePostLegacy({ context, next });
  }
  return nextWithLocalsStub(next, context);
});
async function handlePost({
  context,
  next,
  actionName
}) {
  const { request } = context;
  const baseAction = await getAction(actionName);
  if (!baseAction) {
    throw new AstroError({
      ...ActionQueryStringInvalidError,
      message: ActionQueryStringInvalidError.message(actionName)
    });
  }
  const contentType = request.headers.get("content-type");
  let formData;
  if (contentType && hasContentType(contentType, formContentTypes)) {
    formData = await request.clone().formData();
  }
  const action = baseAction.bind(context);
  const actionResult = await action(formData);
  return handleResult({ context, next, actionName, actionResult });
}
async function handleResult({
  context,
  next,
  actionName,
  actionResult
}) {
  const actionsInternal = {
    getActionResult: (actionFn) => {
      if (actionFn.toString() !== getActionQueryString(actionName)) {
        return Promise.resolve(void 0);
      }
      return actionResult;
    },
    callAction: createCallAction(context),
    actionResult
  };
  const locals = context.locals;
  Object.defineProperty(locals, "_actionsInternal", { writable: false, value: actionsInternal });
  const response = await next();
  if (actionResult.error) {
    return new Response(response.body, {
      status: actionResult.error.status,
      statusText: actionResult.error.type,
      headers: response.headers
    });
  }
  return response;
}
async function handlePostLegacy({ context, next }) {
  const { request } = context;
  if (context.url.pathname.startsWith("/_actions")) return nextWithLocalsStub(next, context);
  const contentType = request.headers.get("content-type");
  let formData;
  if (contentType && hasContentType(contentType, formContentTypes)) {
    formData = await request.clone().formData();
  }
  if (!formData) return nextWithLocalsStub(next, context);
  const actionName = formData.get("_astroAction");
  if (!actionName) return nextWithLocalsStub(next, context);
  const baseAction = await getAction(actionName);
  if (!baseAction) {
    throw new AstroError({
      ...ActionQueryStringInvalidError,
      message: ActionQueryStringInvalidError.message(actionName)
    });
  }
  const action = baseAction.bind(context);
  const actionResult = await action(formData);
  return handleResult({ context, next, actionName, actionResult });
}
function nextWithStaticStub(next, context) {
  Object.defineProperty(context.locals, "_actionsInternal", {
    writable: false,
    value: {
      getActionResult: () => {
        console.warn(
          yellow("[astro:actions]"),
          "`getActionResult()` should not be called on prerendered pages. Astro can only handle actions for pages rendered on-demand."
        );
        return void 0;
      },
      callAction: createCallAction(context)
    }
  });
  return next();
}
function nextWithLocalsStub(next, context) {
  Object.defineProperty(context.locals, "_actionsInternal", {
    writable: false,
    value: {
      getActionResult: () => void 0,
      callAction: createCallAction(context)
    }
  });
  return next();
}
function createCallAction(context) {
  return (baseAction, input) => {
    const action = baseAction.bind(context);
    return action(input);
  };
}
export {
  onRequest
};
